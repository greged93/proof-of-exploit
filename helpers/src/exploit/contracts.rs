use eyre::eyre;
use lazy_static::lazy_static;
use revm_interpreter::primitives::{Address, Bytes, U256};
use std::str::FromStr;

const CHALLENGE_BYTECODE: &str =
    include_str!("../../../test/huff-template/out/Challenge.sol/Challenge.json");
const EXPLOIT_BYTECODE: &str =
    include_str!("../../../test/huff-template/out/Exploit.sol/Exploit.json");

lazy_static! {
    pub static ref CHALLENGE_ADDRESS: Address =
        Address::from_str("0xfEeDC0DE00000000000000000000000000000000").unwrap();
    pub static ref EXPLOIT_BALANCE: U256 = U256::from(1e18 as u64);
    pub static ref EXPLOIT_ADDRESS: Address =
        Address::from_str("0xBAda550000000000000000000000000000000000").unwrap();
}

pub fn get_challenge_deployed_bytecode() -> eyre::Result<Bytes> {
    let contract: alloy_json_abi::ContractObject = serde_json::from_str(CHALLENGE_BYTECODE)?;
    contract
        .deployed_bytecode
        .ok_or_else(|| eyre!("deployed bytecode not found"))
}

pub fn get_exploit_deployed_bytecode() -> eyre::Result<Bytes> {
    let contract: alloy_json_abi::ContractObject = serde_json::from_str(EXPLOIT_BYTECODE)?;
    contract
        .deployed_bytecode
        .ok_or_else(|| eyre!("deployed bytecode not found"))
}

#[cfg(test)]
mod tests {
    use super::{get_challenge_deployed_bytecode, get_exploit_deployed_bytecode};

    #[test]
    fn test_get_challenge_deployed_bytecode() {
        let bytecode = get_challenge_deployed_bytecode().unwrap();
        assert!(!bytecode.is_empty());
    }

    #[test]
    fn test_get_exploit_deployed_bytecode() {
        let bytecode = get_exploit_deployed_bytecode().unwrap();
        assert!(!bytecode.is_empty());
    }
}
