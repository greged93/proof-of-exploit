use alloy::primitives::B256;
use alloy::rpc::types::trace::geth::{GethDebugTracingOptions, GethDefaultTracingOptions};
use anvil::eth::EthApi;
use anvil::NodeConfig;
use revm_interpreter::primitives::{Address, Bytes, U256};
use std::collections::HashSet;
use std::ops::Deref;

#[derive(Clone)]
pub struct LocalProvider(EthApi);

impl LocalProvider {
    /// Creates a new local provider using anvil, forking the chain
    /// with the given Ethereum RPC URL and block number.
    pub async fn new(eth_rpc_url: String, block_number: u64) -> Self {
        let node = NodeConfig::default()
            .with_eth_rpc_url(eth_rpc_url.into())
            .with_fork_block_number(block_number.into())
            .silent()
            .with_steps_tracing(true)
            .with_tracing(true)
            .with_port(8545);
        let (eth_api, _) = anvil::spawn(node).await;

        Self(eth_api)
    }

    /// Returns a tuple containing list of addresses that were touched by the transaction
    /// and the storage slots that were touched by the transaction coupled with the address.
    pub async fn touched_addresses_and_slots(
        &self,
        tx_hash: B256,
    ) -> eyre::Result<(Vec<Address>, Vec<(Address, U256)>)> {
        // Use trace_transaction to fetch the addresses touched by the transaction
        let traces = self.trace_transaction(tx_hash).await?;
        let addresses: Vec<_> = traces
            .into_iter()
            .filter_map(|t| t.trace.action.as_call().map(|c| c.to))
            .collect();

        // Use debug_trace_transaction to fetch the storage slots touched by the transaction and combine
        // with the addresses
        let config = GethDefaultTracingOptions::default().with_disable_storage(false);
        let trace = self
            .debug_trace_transaction(
                tx_hash,
                GethDebugTracingOptions {
                    config,
                    ..Default::default()
                },
            )
            .await?;

        tracing::info!(target: "helpers::provider", ?addresses, ?trace);
        // TODO make compiler happy
        let clone_addresses = addresses.clone();
        let slots = trace
            .try_into_default_frame()?
            .struct_logs
            .into_iter()
            .filter(|log| log.storage.is_some())
            .flat_map(|log| {
                // Depth starts from 1.
                // Use the depth to get the address of the current contract
                tracing::info!(target: "helpers::provider", depth = ?log.depth);
                let address = clone_addresses
                    .get((log.depth - 1) as usize)
                    .copied()
                    .expect("address not found");
                log.storage
                    .unwrap() // safe due to `filter_map`
                    .into_iter()
                    .map(move |s| (address, U256::from_be_slice(s.0.as_slice())))
            });

        let unique_addresses: HashSet<Address> = addresses.into_iter().collect();
        let unique_slots: HashSet<(Address, U256)> = slots.collect();

        tracing::info!(target: "helpers::provider", ?unique_addresses, ?unique_slots);

        Ok((
            unique_addresses.into_iter().collect(),
            unique_slots.into_iter().collect(),
        ))
    }

    /// Returns a list of tuples containing the address
    /// and its corresponding bytecode for the given
    /// block.
    pub async fn get_codes(
        &self,
        addresses: Vec<Address>,
        block_number: u64,
    ) -> eyre::Result<Vec<(Address, Bytes)>> {
        let mut bytecodes = Vec::new();
        for address in addresses {
            let code = self.get_code(address, Some(block_number.into())).await?;
            bytecodes.push((address, code));
        }
        bytecodes.retain(|(_, code)| !code.is_empty());
        Ok(bytecodes)
    }

    /// Returns a list of tuples containing the address
    /// and its corresponding balance for the given
    /// block.
    pub async fn get_balances(
        &self,
        addresses: Vec<Address>,
        block_number: u64,
    ) -> eyre::Result<Vec<(Address, U256)>> {
        let mut balances = Vec::new();
        for address in addresses {
            let code = self.balance(address, Some(block_number.into())).await?;
            balances.push((address, code));
        }
        balances.retain(|(_, balance)| balance != &U256::ZERO);
        Ok(balances)
    }

    /// Returns a list of tuples containing the address
    /// and its corresponding storage value for the given
    /// block.
    pub async fn get_storages(
        &self,
        slots: Vec<(Address, U256)>,
        block_number: u64,
    ) -> eyre::Result<Vec<((Address, U256), U256)>> {
        let mut storages = Vec::new();
        for (address, index) in slots {
            let value = self
                .storage_at(address, index, Some(block_number.into()))
                .await?;
            storages.push(((address, index), U256::from_be_slice(value.as_slice())));
        }
        storages.retain(|(_, storage)| storage != &U256::ZERO);
        Ok(storages)
    }
}

impl Deref for LocalProvider {
    type Target = EthApi;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
