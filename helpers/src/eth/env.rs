use alloy::primitives::U256;
use alloy::rpc::types::{Block, Transaction};
use eyre::eyre;
use revm_interpreter::primitives::bitvec::macros::internal::funty::Fundamental;
use revm_interpreter::primitives::{BlobExcessGasAndPrice, BlockEnv};

pub fn tx_env(tx: Transaction) -> exploit_program::TxEnv {
    exploit_program::TxEnv {
        caller: tx.from,
        data: tx.input,
        gas_limit: tx.gas.as_u64(),
        gas_price: U256::from(tx.gas_price.unwrap_or_default()),
        transact_to: tx.to.into(),
        value: tx.value,
        nonce: Some(tx.nonce),
        chain_id: tx.chain_id,
        ..Default::default()
    }
}

pub fn block_env(block: Block) -> eyre::Result<BlockEnv> {
    let is_blob_block = block.header.excess_blob_gas.is_some();

    Ok(BlockEnv {
        number: U256::from(
            block
                .header
                .number
                .ok_or_else(|| eyre!("block number not found"))?,
        ),
        coinbase: block.header.miner,
        timestamp: U256::from(block.header.timestamp),
        gas_limit: U256::from(block.header.gas_limit),
        basefee: U256::from(block.header.base_fee_per_gas.unwrap_or_default()),
        difficulty: U256::from(block.header.difficulty),
        prevrandao: block.header.mix_hash,
        blob_excess_gas_and_price: if is_blob_block {
            Some(BlobExcessGasAndPrice::new(
                block.header.excess_blob_gas.unwrap_or_default().as_u64(),
            ))
        } else {
            None
        },
    })
}
