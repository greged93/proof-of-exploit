use alloy::primitives::TxKind;
use revm_interpreter::primitives::{Address, BlockEnv, Bytes, CfgEnv, U256};
use serde::{Deserialize, Serialize};

/// This structure represents the environment for
/// the transaction. It is used in place of
/// [`revm_interpreter::primitives::TxEnv`] due
/// to the field `optimism` being on by default
/// due to the import of the `anvil` crate. The
/// `optimism` field uses `serde::flatten` and as
/// such cannot be serialized by `bincode`.
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TxEnv {
    /// Caller aka Author aka transaction signer.
    pub caller: Address,
    /// The gas limit of the transaction.
    pub gas_limit: u64,
    /// The gas price of the transaction.
    pub gas_price: U256,
    /// The destination of the transaction.
    pub transact_to: TxKind,
    /// The value sent to `transact_to`.
    pub value: U256,
    /// The data of the transaction.
    pub data: Bytes,
    /// The nonce of the transaction.
    pub nonce: Option<u64>,
    /// The chain ID of the transaction. If set to `None`, no checks are performed.
    pub chain_id: Option<u64>,
}

impl From<TxEnv> for revm_interpreter::primitives::TxEnv {
    fn from(tx_env: TxEnv) -> Self {
        revm_interpreter::primitives::TxEnv {
            caller: tx_env.caller,
            gas_limit: tx_env.gas_limit,
            gas_price: tx_env.gas_price,
            transact_to: tx_env.transact_to,
            value: tx_env.value,
            data: tx_env.data,
            nonce: tx_env.nonce,
            chain_id: tx_env.chain_id,
            ..Default::default()
        }
    }
}

/// The input to the generation of environment proof
/// for the execution environment.
// TODO kept getting `deserialization failed: Io(Custom { kind: UnexpectedEof, error: "" })`
// TODO when using these types.
#[derive(Serialize, Deserialize, Default, Debug)]
pub struct EnvProvingInput {
    /// Block environment context
    pub block_env: BlockEnv,
    /// Cfg environment context
    pub cfg_env: CfgEnv,
    /// Tx environment context
    pub tx_env: TxEnv,
}

impl EnvProvingInput {
    pub fn new(block_env: BlockEnv, cfg_env: CfgEnv, tx_env: TxEnv) -> Self {
        Self {
            block_env,
            cfg_env,
            tx_env,
        }
    }
}

pub type Addresses = Vec<Address>;
pub type Bytecodes = Vec<(Address, Bytes)>;
pub type Balances = Vec<(Address, U256)>;
pub type Storages = Vec<((Address, U256), U256)>;
pub type Nonces = Vec<(Address, u64)>;
pub type ProvingCommitSlot = (Address, U256);

/// The input to the generation of exploit proof
/// related to storage
#[derive(Serialize, Deserialize, Default, Debug)]
pub struct StateProvingInput {
    /// The bytecodes for the execution env
    pub bytecodes: Bytecodes,
    /// The balances for the execution env
    pub balances: Balances,
    /// The storage values for the execution env
    pub storages: Storages,
    /// The nonces for the execution env
    pub nonces: Nonces,
}

impl StateProvingInput {
    pub fn new(
        bytecodes: Vec<(Address, Bytes)>,
        balances: Vec<(Address, U256)>,
        storages: Vec<((Address, U256), U256)>,
        nonces: Vec<(Address, u64)>,
    ) -> Self {
        Self {
            bytecodes,
            balances,
            storages,
            nonces,
        }
    }
}
