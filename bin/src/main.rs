use clap::Parser;
use eyre::eyre;
use helpers::eth::env::{block_env, tx_env};
use helpers::eth::provider::LocalProvider;
use helpers::exploit::contracts::{
    get_challenge_deployed_bytecode, get_exploit_deployed_bytecode, CHALLENGE_ADDRESS,
    EXPLOIT_ADDRESS, EXPLOIT_BALANCE,
};
use helpers::exploit::signer::{PRIVATE_KEY, SIGNER_ADDRESS};
use reth_primitives::{sign_message, Bytes, TransactionSigned, TxKind, TxLegacy};
use revm_interpreter::primitives::{CfgEnv, B256, U256};
use sp1_sdk::{ProverClient, SP1Stdin};
use std::str::FromStr;

pub const ELF: &[u8] = include_bytes!("../../elf/riscv32im-succinct-zkvm-elf");

#[derive(Parser)]
pub struct InputArgs {
    #[arg(long)]
    block_number: u64,
    #[arg(long)]
    eth_rpc_url: String,
}

#[tokio::main]
async fn main() -> eyre::Result<()> {
    // Set up the logger
    setup();

    let args = InputArgs::parse();
    let bn = args.block_number;

    // Set up the anvil provider and fetch the block
    let provider = LocalProvider::new(args.eth_rpc_url.clone(), bn).await;
    let chain_id = provider.chain_id();

    // Setup the contracts
    setup_contracts(&provider).await?;

    // Send the exploit transaction
    let tx_hash = send_exploit_transaction(provider.clone(), chain_id).await?;
    tracing::info!(?tx_hash, "exploit transaction sent");

    // Fetch the transaction
    tracing::info!("Fetching transaction");
    let tx = provider
        .transaction_by_hash(tx_hash)
        .await?
        .ok_or_else(|| eyre!("unknown tx"))?;
    // TODO wait for the transaction to be mined
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;

    // Wait for the receipt
    let receipt = provider
        .transaction_receipt(tx_hash)
        .await?
        .ok_or_else(|| eyre!("unknown receipt"))?;
    let bn = receipt
        .block_number
        .ok_or_else(|| eyre!("unknown block number"))?;
    let sender = receipt.from;

    // Fetch the block
    tracing::info!("Fetching block");
    let block = provider
        .block_by_number_full(bn.into())
        .await?
        .ok_or_else(|| eyre!("unknown block hash"))?;

    // Construct the environments
    let block_env = block_env(block)?;
    let cfg_env = CfgEnv::default().with_chain_id(chain_id);
    let tx_env = tx_env(tx.inner);

    // Load bytecodes, balances and storages
    tracing::info!("Fetching bytecodes, balances and storages");
    let (mut touched_addresses, touched_slots) =
        provider.touched_addresses_and_slots(tx_hash).await?;

    // Add the transaction sender to the touched addresses
    touched_addresses.push(sender);

    // Fetch the bytecodes
    let bytecodes = provider
        .get_codes(touched_addresses.clone(), bn - 1)
        .await?;

    // Fetch the balances
    let balances = provider
        .get_balances(touched_addresses.clone(), bn - 1)
        .await?;

    // Fetch the storages
    let storages = provider.get_storages(touched_slots, bn - 1).await?;
    tracing::info!(?bytecodes, ?storages, ?balances);

    // Fetch the nonces
    let nonces = provider.get_nonces(touched_addresses, bn - 1).await?;
    tracing::info!(bytecodes_len = ?bytecodes.len(), ?storages, ?balances, ?nonces);

    // Init the prover
    let client = ProverClient::local();

    // Create a new SP1Stdin instance and write the guesses to it
    let mut input = SP1Stdin::new();

    // Write the ExecutionHost
    input.write(&block_env);
    input.write(&cfg_env);
    input.write(&tx_env);
    input.write(&bytecodes);
    input.write(&balances);
    input.write(&storages);
    input.write(&nonces);
    input.write(&(*CHALLENGE_ADDRESS, U256::ZERO));

    // Execute the exploit
    let (values, report) = client
        .execute(ELF, input)
        .map_err(|err| eyre!(err.to_string()))?;
    tracing::info!("exploited");
    tracing::trace!(?report);

    // Deserialize the updated state from the public values
    let final_state: U256 =
        bincode::deserialize(&values.to_vec()).map_err(|err| eyre!(err.to_string()))?;

    // Display the final state
    tracing::info!(?final_state, "state after exploit");

    Ok(())
}

/// Setup the tracing subscriber
fn setup() {
    let filter = tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| {
        tracing_subscriber::EnvFilter::from_str("helpers=info,prove_exploit=info")
            .expect("failed to parse filter")
    });
    tracing_subscriber::FmtSubscriber::builder()
        .with_env_filter(filter)
        .try_init()
        .expect("Failed to initialize the logger");
}

/// Set up the exploit for the exploit [here](https://github.com/proof-of-exploit/huff-template)
async fn setup_contracts(local_provider: &LocalProvider) -> eyre::Result<()> {
    let challenge_bytecode = get_challenge_deployed_bytecode()?;
    let exploit_bytecode = get_exploit_deployed_bytecode()?;

    // Deploy the challenge contract
    local_provider
        .anvil_set_code(*CHALLENGE_ADDRESS, challenge_bytecode)
        .await?;

    // Deploy the exploit contract
    local_provider
        .anvil_set_code(*EXPLOIT_ADDRESS, exploit_bytecode)
        .await?;

    // Set the balance of the exploit contract
    local_provider
        .anvil_set_balance(*EXPLOIT_ADDRESS, *EXPLOIT_BALANCE)
        .await?;
    Ok(())
}

async fn send_exploit_transaction(
    local_provider: LocalProvider,
    chain_id: u64,
) -> eyre::Result<B256> {
    // Fetch account nonce
    let nonce = local_provider
        .transaction_count(*SIGNER_ADDRESS, None)
        .await?;

    // Prepare the transaction
    let transaction = reth_primitives::Transaction::Legacy(TxLegacy {
        chain_id: Some(chain_id),
        nonce: nonce.to(),
        gas_price: 0,
        gas_limit: 1_000_000,
        to: TxKind::Call(*CHALLENGE_ADDRESS),
        value: Default::default(),
        input: Bytes::from_str("0xb0d691fe").unwrap(),
    });

    // Sign the transaction
    let signature = sign_message(*PRIVATE_KEY, transaction.signature_hash())?;
    let signed_transaction =
        TransactionSigned::from_transaction_and_signature(transaction, signature);

    // Send the transaction
    let mut raw = Vec::new();
    signed_transaction.encode_enveloped(&mut raw);
    let tx_hash = local_provider.send_raw_transaction(raw.into()).await?;

    Ok(tx_hash)
}
