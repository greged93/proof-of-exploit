use alloy_signer_local::PrivateKeySigner;
use lazy_static::lazy_static;
use revm_interpreter::primitives::{Address, B256};
use revm_interpreter::primitives::{Bytes, U256};
use std::str::FromStr;

lazy_static! {
    pub static ref PRIVATE_KEY: B256 =
        B256::from_str("0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80")
            .unwrap();
    pub static ref SIGNER: PrivateKeySigner = PrivateKeySigner::from_bytes(&PRIVATE_KEY).unwrap();
    pub static ref SIGNER_ADDRESS: Address = SIGNER.address();
}

pub(super) const CHALLENGE_BYTECODE: &str =
    include_str!("../../../../test/huff-template/out/Challenge.sol/Challenge.json");
pub(super) const EXPLOIT_BYTECODE: &str =
    include_str!("../../../../test/huff-template/out/Exploit.sol/Exploit.json");

lazy_static! {
    pub static ref VAULT_ADDRESS: Address =
        Address::from_str("0x4330E5E62a8FB0219900b20f4c6C78D11Bf9D1f5").unwrap();
    pub static ref CHALLENGE_ADDRESS: Address =
        Address::from_str("0xfEeDC0DE00000000000000000000000000000000").unwrap();
    pub static ref EXPLOIT_BALANCE: U256 = U256::from(1e18 as u64);
    pub static ref EXPLOIT_ADDRESS: Address =
        Address::from_str("0xBAda550000000000000000000000000000000000").unwrap();
    pub static ref EXPLOIT_INPUT: Bytes = Bytes::from_str("0xb0d691fe").unwrap();
}
