pub mod constants;
#[cfg(test)]
pub mod tests;
pub mod utils;

use self::constants::{CHALLENGE_ADDRESS, EXPLOIT_ADDRESS, EXPLOIT_BALANCE};
use self::constants::{PRIVATE_KEY, SIGNER_ADDRESS};
use crate::commands::common::env::envs;
use crate::commands::common::provider::LocalProvider;
use crate::commands::example::utils::{
    get_challenge_deployed_bytecode, get_exploit_deployed_bytecode,
};
use crate::commands::ELF;
use clap::Parser;
use eyre::eyre;
use reth_primitives::{sign_message, Bytes, TransactionSigned, TxKind, TxLegacy, B256};
use revm_interpreter::primitives::U256;
use sp1_sdk::{ProverClient, SP1Stdin};
use std::str::FromStr;

#[derive(Parser)]
pub struct ExampleCmd {
    #[arg(long)]
    eth_rpc_url: String,
}

impl ExampleCmd {
    pub async fn run(self) -> eyre::Result<()> {
        const BLOCK_NUMBER: u64 = 4774970;

        // Set up the anvil provider
        let provider = LocalProvider::new(self.eth_rpc_url.clone(), BLOCK_NUMBER).await;
        let chain_id = provider.chain_id();

        // Setup the contracts
        setup_contracts(&provider).await?;

        // Send the exploit transaction
        let tx_hash = send_exploit_transaction(provider.clone(), chain_id).await?;
        tracing::info!(?tx_hash, "exploit transaction sent");

        // Fetch the transaction
        tracing::info!("Fetching transaction");
        let tx = provider
            .transaction_by_hash(tx_hash)
            .await?
            .ok_or_else(|| eyre!("unknown tx"))?;
        // Wait for the block to be auto-mined
        tokio::time::sleep(std::time::Duration::from_millis(200)).await;

        // Wait for the receipt
        let receipt = provider
            .transaction_receipt(tx_hash)
            .await?
            .ok_or_else(|| eyre!("unknown receipt"))?;
        let bn = receipt
            .block_number
            .ok_or_else(|| eyre!("unknown block number"))?;

        // Fetch the block
        tracing::info!("Fetching block");
        let block = provider
            .block_by_number_full(bn.into())
            .await?
            .ok_or_else(|| eyre!("unknown block hash"))?;

        // Construct the environments
        let (block_env, cfg_env, tx_env) = envs(block, tx.inner, chain_id);

        // Fetch the touched state
        let touched_state = provider.fetch_touched_state(tx_hash, bn - 1).await?;

        // Init the prover
        let client = ProverClient::local();

        // Create a new SP1Stdin instance and write the guesses to it
        let mut input = SP1Stdin::new();

        // Write the ExecutionHost
        input.write(&block_env);
        input.write(&cfg_env);
        input.write(&tx_env);
        input.write(&touched_state.bytecodes);
        input.write(&touched_state.balances);
        input.write(&touched_state.storages);
        input.write(&touched_state.nonces);
        input.write(&vec![(*CHALLENGE_ADDRESS, U256::ZERO)]);

        // Execute the exploit
        let (values, report) = client
            .execute(ELF, input)
            .map_err(|err| eyre!(err.to_string()))?;
        tracing::info!("exploited");
        tracing::trace!(?report);

        // Deserialize the updated state from the public values
        let final_state: Vec<U256> =
            bincode::deserialize(&values.to_vec()).map_err(|err| eyre!(err.to_string()))?;

        // Display the final state
        tracing::info!(?final_state, "state should be 1 after exploit");

        Ok(())
    }
}

/// Set up the exploit from [here](https://github.com/proof-of-exploit/huff-template)
async fn setup_contracts(local_provider: &LocalProvider) -> eyre::Result<()> {
    let challenge_bytecode = get_challenge_deployed_bytecode()?;
    let exploit_bytecode = get_exploit_deployed_bytecode()?;

    // Deploy the challenge contract
    local_provider
        .anvil_set_code(*CHALLENGE_ADDRESS, challenge_bytecode)
        .await?;

    // Deploy the exploit contract
    local_provider
        .anvil_set_code(*EXPLOIT_ADDRESS, exploit_bytecode)
        .await?;

    // Set the balance of the exploit contract
    local_provider
        .anvil_set_balance(*EXPLOIT_ADDRESS, *EXPLOIT_BALANCE)
        .await?;
    Ok(())
}

/// Prepares, signs and sends the exploit transaction
async fn send_exploit_transaction(
    local_provider: LocalProvider,
    chain_id: u64,
) -> eyre::Result<B256> {
    // Fetch account nonce
    let nonce = local_provider
        .transaction_count(*SIGNER_ADDRESS, None)
        .await?;

    // Prepare the transaction
    let transaction = reth_primitives::Transaction::Legacy(TxLegacy {
        chain_id: Some(chain_id),
        nonce: nonce.to(),
        gas_price: 0,
        gas_limit: 1_000_000,
        to: TxKind::Call(*CHALLENGE_ADDRESS),
        value: Default::default(),
        input: Bytes::from_str("0xb0d691fe").unwrap(),
    });

    // Sign the transaction
    let signature = sign_message(*PRIVATE_KEY, transaction.signature_hash())?;
    let signed_transaction =
        TransactionSigned::from_transaction_and_signature(transaction, signature);

    // Send the transaction
    let mut raw = Vec::new();
    signed_transaction.encode_enveloped(&mut raw);
    let tx_hash = local_provider.send_raw_transaction(raw.into()).await?;

    Ok(tx_hash)
}
