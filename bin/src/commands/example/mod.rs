pub mod constants;
#[cfg(test)]
pub mod tests;
pub mod utils;

use self::constants::{CHALLENGE_ADDRESS, EXPLOIT_ADDRESS, EXPLOIT_BALANCE};
use crate::commands::example::constants::EXPLOIT_INPUT;
use crate::commands::example::utils::{
    get_challenge_deployed_bytecode, get_exploit_deployed_bytecode,
};
use crate::commands::ELF;
use crate::utils::env::envs;
use crate::utils::prepare_and_send_transaction;
use crate::utils::provider::LocalProvider;
use alloy::primitives::TxKind;
use clap::Parser;
use eyre::eyre;
use revm_interpreter::primitives::U256;
use sp1_sdk::{ProverClient, SP1Stdin};

#[derive(Parser)]
pub struct ExampleCmd {
    #[arg(long)]
    eth_rpc_url: String,
}

impl ExampleCmd {
    pub async fn run(self) -> eyre::Result<()> {
        const BLOCK_NUMBER: u64 = 4774970;

        // Set up the anvil provider
        let provider = LocalProvider::new(self.eth_rpc_url.clone(), BLOCK_NUMBER).await;
        let chain_id = provider.chain_id();

        // Setup the contracts
        setup_contracts(&provider).await?;

        // Send the exploit transaction
        let tx_hash = prepare_and_send_transaction(
            &provider,
            chain_id,
            EXPLOIT_INPUT.clone(),
            TxKind::Call(*CHALLENGE_ADDRESS),
        )
        .await?;
        tracing::info!(?tx_hash, "exploit transaction sent");

        // Fetch the transaction
        tracing::info!("Fetching transaction");
        let tx = provider
            .transaction_by_hash(tx_hash)
            .await?
            .ok_or_else(|| eyre!("unknown tx"))?;

        // Wait for the receipt
        let receipt = provider
            .transaction_receipt(tx_hash)
            .await?
            .ok_or_else(|| eyre!("unknown receipt"))?;
        let bn = receipt
            .block_number
            .ok_or_else(|| eyre!("unknown block number"))?;

        // Fetch the block
        tracing::info!("Fetching block");
        let block = provider
            .block_by_number_full(bn.into())
            .await?
            .ok_or_else(|| eyre!("unknown block hash"))?;

        // Construct the environments
        let (block_env, cfg_env, tx_env) = envs(block, tx.inner, chain_id);

        // Fetch the touched state
        let touched_state = provider.fetch_touched_state(tx_hash, bn - 1).await?;

        // Init the prover
        let client = ProverClient::local();

        // Create a new SP1Stdin instance and write the guesses to it
        let mut input = SP1Stdin::new();

        // Write the ExecutionHost
        input.write(&block_env);
        input.write(&cfg_env);
        input.write(&tx_env);
        input.write(&touched_state.bytecodes);
        input.write(&touched_state.balances);
        input.write(&touched_state.storages);
        input.write(&touched_state.nonces);
        input.write(&vec![(*CHALLENGE_ADDRESS, U256::ZERO)]);

        // Execute the exploit
        let (values, report) = client
            .execute(ELF, input)
            .map_err(|err| eyre!(err.to_string()))?;
        tracing::info!("exploited");
        tracing::trace!(?report);

        // Deserialize the updated state from the public values
        let final_state: Vec<U256> =
            bincode::deserialize(&values.to_vec()).map_err(|err| eyre!(err.to_string()))?;

        // Display the final state
        tracing::info!(?final_state, "state should be 1 after exploit");

        Ok(())
    }
}

/// Set up the exploit from [here](https://github.com/proof-of-exploit/huff-template)
async fn setup_contracts(local_provider: &LocalProvider) -> eyre::Result<()> {
    let challenge_bytecode = get_challenge_deployed_bytecode()?;
    let exploit_bytecode = get_exploit_deployed_bytecode()?;

    // Deploy the challenge contract
    local_provider
        .anvil_set_code(*CHALLENGE_ADDRESS, challenge_bytecode)
        .await?;

    // Deploy the exploit contract
    local_provider
        .anvil_set_code(*EXPLOIT_ADDRESS, exploit_bytecode)
        .await?;

    // Set the balance of the exploit contract
    local_provider
        .anvil_set_balance(*EXPLOIT_ADDRESS, *EXPLOIT_BALANCE)
        .await?;
    Ok(())
}
