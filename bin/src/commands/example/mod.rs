pub mod constants;
#[cfg(test)]
pub mod tests;
pub mod utils;

use self::constants::{CHALLENGE_ADDRESS, EXPLOIT_ADDRESS, EXPLOIT_BALANCE};
use crate::commands::constants::{ANVIL_PORT, SIGNER};
use crate::commands::example::constants::EXPLOIT_INPUT;
use crate::commands::example::utils::{
    get_challenge_deployed_bytecode, get_exploit_deployed_bytecode,
};
use crate::utils::env::envs;
use crate::utils::exploit_prover::ExploitProver;
use crate::utils::provider::LocalProvider;
use crate::utils::tx_handler::TransactionHandler;
use clap::Parser;
use exploit_program::prover_types::EnvProvingInput;
use eyre::eyre;
use revm_interpreter::primitives::U256;

#[derive(Parser)]
pub struct ExampleCmd {
    #[arg(long)]
    eth_rpc_url: String,
}

impl ExampleCmd {
    pub async fn run(self) -> eyre::Result<()> {
        const BLOCK_NUMBER: u64 = 4774970;

        // Set up the anvil provider
        let provider = LocalProvider::new(self.eth_rpc_url.clone(), BLOCK_NUMBER, ANVIL_PORT).await;
        let chain_id = provider.chain_id();

        // Set up the transaction handler
        let tx_handler = TransactionHandler::new(&provider, SIGNER.clone());

        // Setup the contracts
        setup_contracts(&provider).await?;

        // Send the exploit transaction
        let tx_hash = tx_handler
            .with_input(EXPLOIT_INPUT.clone())
            .with_to(*CHALLENGE_ADDRESS)
            .build()
            .send()
            .await?;
        tracing::info!(?tx_hash, "exploit transaction sent");

        // Fetch the transaction
        tracing::info!("Fetching transaction");
        let tx = provider
            .transaction_by_hash(tx_hash)
            .await?
            .ok_or_else(|| eyre!("unknown tx"))?;

        // Wait for the receipt
        let receipt = provider
            .transaction_receipt(tx_hash)
            .await?
            .ok_or_else(|| eyre!("unknown receipt"))?;
        let bn = receipt
            .block_number
            .ok_or_else(|| eyre!("unknown block number"))?;

        // Fetch the block
        tracing::info!("Fetching block");
        let block = provider
            .block_by_number_full(bn.into())
            .await?
            .ok_or_else(|| eyre!("unknown block hash"))?;

        // Construct the environments
        let (block_env, cfg_env, tx_env) = envs(block, tx.inner, chain_id);

        // Fetch the touched state
        let touched_state = provider.fetch_touched_state(tx_hash, bn - 1).await?;

        // Init the prover
        let prover = ExploitProver::new(
            EnvProvingInput::new(block_env, cfg_env, tx_env),
            touched_state,
            vec![(*CHALLENGE_ADDRESS, U256::ZERO)],
        );

        // Prove the exploit
        prover.prove()?;

        Ok(())
    }
}

/// Set up the exploit from [here](https://github.com/proof-of-exploit/huff-template)
async fn setup_contracts(local_provider: &LocalProvider) -> eyre::Result<()> {
    let challenge_bytecode = get_challenge_deployed_bytecode()?;
    let exploit_bytecode = get_exploit_deployed_bytecode()?;

    // Deploy the challenge contract
    local_provider
        .anvil_set_code(*CHALLENGE_ADDRESS, challenge_bytecode)
        .await?;

    // Deploy the exploit contract
    local_provider
        .anvil_set_code(*EXPLOIT_ADDRESS, exploit_bytecode)
        .await?;

    // Set the balance of the exploit contract
    local_provider
        .anvil_set_balance(*EXPLOIT_ADDRESS, *EXPLOIT_BALANCE)
        .await?;
    Ok(())
}
