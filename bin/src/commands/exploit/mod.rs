use crate::commands::constants::{ANVIL_PORT, SIGNER};
use crate::utils::env::envs;
use crate::utils::exploit_prover::ExploitProver;
use crate::utils::provider::LocalProvider;
use crate::utils::tx_handler::TransactionHandler;
use clap::Parser;
use common::EnvProvingInput;
use eyre::eyre;
use reth_primitives::Address;
use revm_interpreter::primitives::{Bytes, U256};
use std::path::PathBuf;
use std::str::FromStr;

#[derive(Parser)]
pub struct ExploitCmd {
    #[arg(long)]
    pub block_number: u64,
    #[arg(long)]
    pub eth_rpc_url: String,
    #[arg(long)]
    contract_path: String,
    #[arg(long)]
    transaction_input: String,
    #[arg(long)]
    pub exploited_slots: Vec<U256>,
}

impl ExploitCmd {
    pub async fn run(self) -> eyre::Result<()> {
        // Set up the anvil provider
        let provider =
            LocalProvider::new(self.eth_rpc_url.clone(), self.block_number, ANVIL_PORT).await;
        let chain_id = provider.chain_id();
        let input = Bytes::from_str(&self.transaction_input)?;
        let handler = TransactionHandler::new(&provider, SIGNER.clone());

        // Deploy the contract
        let address = deploy_contract((&self.contract_path).into(), &provider).await?;

        // Send the transaction
        let tx_hash = handler
            .with_input(input.clone())
            .with_to(address)
            .build()
            .send()
            .await?;

        // Fetch the latest transaction
        let block = provider
            .block_by_number_full(Default::default())
            .await?
            .ok_or_else(|| eyre!("unknown block number"))?;
        let block_number = block
            .header
            .number
            .ok_or_else(|| eyre!("block number not found"))?;

        let tx = block
            .transactions
            .as_transactions()
            .expect("should be full block")
            .last()
            .cloned()
            .ok_or_else(|| eyre!("block empty, expected exploit transaction"))?;

        // Construct the environments
        let (block_env, cfg_env, tx_env) = envs(block, tx, chain_id);

        // Fetch the touched state
        let touched_state = provider
            .fetch_touched_state(tx_hash, block_number - 1)
            .await?;

        // Prepare the slots to commit to
        let slots = self
            .exploited_slots
            .into_iter()
            .map(|slot| (address, slot))
            .collect::<Vec<_>>();
        tracing::info!(?slots);

        let prover = ExploitProver::new(
            EnvProvingInput::new(block_env, cfg_env, tx_env),
            touched_state.into(),
            slots,
        );

        // Prove the exploit
        prover.prove()?;

        Ok(())
    }
}

/// Deploy the contract at the provided path onto the network.
async fn deploy_contract(path: PathBuf, provider: &LocalProvider) -> eyre::Result<Address> {
    // Compile the contract
    compile_contract(&path)?;

    // Read the compiled contract
    // solcjs compiles the contract with a name
    // which contains the  where '.' and '/' are replaced with '_'
    let stem = path
        .file_stem()
        .unwrap_or_default()
        .to_str()
        .unwrap_or_default();
    let path = path.to_str().unwrap_or_default();
    let path = path.replace(['/', '.'], "_");

    let artifact_path = format!("./artifacts/{}_{}.bin", path, stem);
    let raw = std::fs::read_to_string(artifact_path)?;

    // Convert to bytes
    let bytecode = Bytes::from_str(&raw)?;

    // Deploy the contract
    let tx_hash = TransactionHandler::new(provider, SIGNER.clone())
        .with_input(bytecode)
        .build()
        .send()
        .await?;
    let receipt = provider
        .transaction_receipt(tx_hash)
        .await?
        .ok_or_else(|| eyre!("no receipt"))?;

    receipt
        .contract_address
        .ok_or_else(|| eyre!("no contract address"))
}

/// Compile the provided contract and store it in the artifacts directory
fn compile_contract(path: &PathBuf) -> eyre::Result<()> {
    let output = std::process::Command::new("solcjs")
        .arg("--output-dir")
        .arg("./artifacts")
        .arg("--bin")
        .arg(path)
        .output()?;
    if !output.status.success() {
        return Err(eyre!("failed to compile contract"));
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::{compile_contract, deploy_contract};
    use crate::utils::provider::LocalProvider;
    use rand::random;

    const CONTRACT_PATH: &str =
        "../test/exploits/wrong_constructor_name/Rubixi_source_code/Rubixi.sol";

    #[test]
    fn test_compile_contract() {
        let path = std::path::PathBuf::from(CONTRACT_PATH);

        // Compile the contract
        let res = compile_contract(&path);
        assert!(res.is_ok());

        // Cleanup
        std::fs::remove_dir_all("./artifacts").unwrap()
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_deploy() -> eyre::Result<()> {
        // Start the provider
        let port = random();
        let path = std::path::PathBuf::from(CONTRACT_PATH);
        let provider =
            LocalProvider::new("https://gateway.tenderly.co/public/sepolia".into(), 0, port).await;

        let address = deploy_contract(path, &provider).await?;

        let code = provider.get_code(address, None).await?;

        assert!(!code.is_empty());

        // Cleanup
        std::fs::remove_dir_all("./artifacts").unwrap();

        Ok(())
    }
}
