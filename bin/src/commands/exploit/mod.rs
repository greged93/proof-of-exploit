use super::common::env::envs;
use super::common::provider::LocalProvider;
use crate::commands::ELF;
use clap::Parser;
use eyre::eyre;
use revm_interpreter::primitives::{Address, U256};
use sp1_sdk::{ProverClient, SP1Stdin};
use std::str::FromStr;

#[derive(Clone)]
pub struct Slot(Address, U256);

impl FromStr for Slot {
    type Err = eyre::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut parts = s.split(':');
        let address = parts
            .next()
            .map(|s| format!("0x{:0>40}", s.trim_start_matches("0x")))
            .ok_or_else(|| eyre!("missing address"))?
            .parse()?;
        let value = parts
            .next()
            .map(|s| format!("0x{:0>64}", s.trim_start_matches("0x")))
            .ok_or_else(|| eyre!("missing value"))?
            .parse()?;
        Ok(Slot(address, value))
    }
}

#[derive(Parser)]
pub struct ExploitCmd {
    #[arg(long)]
    pub block_number: u64,
    #[arg(long)]
    pub eth_rpc_url: String,
    #[arg(long, value_delimiter = ' ')]
    pub exploited_slots: Vec<Slot>,
}

impl ExploitCmd {
    pub async fn run(self) -> eyre::Result<()> {
        // Set up the anvil provider
        let provider = LocalProvider::new(self.eth_rpc_url.clone(), self.block_number).await;
        let chain_id = provider.chain_id();

        println!("Anvil is ready...");
        println!("Waiting for the exploit to be sent... Press enter once state is set and exploit transaction has been sent.");
        let _ = tokio::io::AsyncReadExt::read(&mut tokio::io::stdin(), &mut [0u8]).await?;

        // Fetch the latest transaction
        let block = provider
            .block_by_number_full(Default::default())
            .await?
            .ok_or_else(|| eyre!("unknown block number"))?;
        let block_number = block
            .header
            .number
            .ok_or_else(|| eyre!("block number not found"))?;

        let tx = block
            .transactions
            .as_transactions()
            .expect("should be full block")
            .last()
            .cloned()
            .ok_or_else(|| eyre!("block empty, expected exploit transaction"))?;
        let tx_hash = tx.hash;

        // Construct the environments
        let (block_env, cfg_env, tx_env) = envs(block, tx, chain_id);

        // Fetch the touched state
        let touched_state = provider
            .fetch_touched_state(tx_hash, block_number - 1)
            .await?;

        // Init the prover
        let client = ProverClient::local();

        // Create a new SP1Stdin instance and write the guesses to it
        let mut input = SP1Stdin::new();

        // Prepare the slots to commit to
        let slots = self
            .exploited_slots
            .iter()
            .map(|slot| (slot.0, slot.1))
            .collect::<Vec<_>>();
        tracing::info!(?slots);

        // Write the ExecutionHost
        input.write(&block_env);
        input.write(&cfg_env);
        input.write(&tx_env);
        input.write(&touched_state.bytecodes);
        input.write(&touched_state.balances);
        input.write(&touched_state.storages);
        input.write(&touched_state.nonces);
        input.write(&slots);

        // Execute the exploit
        let (values, report) = client
            .execute(ELF, input)
            .map_err(|err| eyre!(err.to_string()))?;
        tracing::info!("exploited");
        tracing::trace!(?report);

        // Deserialize the updated state from the public values
        let final_state: Vec<U256> =
            bincode::deserialize(&values.to_vec()).map_err(|err| eyre!(err.to_string()))?;

        // Display the final state
        tracing::info!(?final_state);

        Ok(())
    }
}
