mod constants;

use crate::commands::ELF;
use crate::utils::env::envs;
use crate::utils::provider::LocalProvider;
use clap::Parser;
use eyre::eyre;
use revm_interpreter::primitives::{Address, Bytes, U256};
use sp1_sdk::{ProverClient, SP1Stdin};
use std::path::{Path, PathBuf};
use std::str::FromStr;

#[derive(Clone)]
pub struct Slot(Address, U256);

impl FromStr for Slot {
    type Err = eyre::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut parts = s.split(':');
        let address = parts
            .next()
            .map(|s| format!("0x{:0>40}", s.trim_start_matches("0x")))
            .ok_or_else(|| eyre!("missing address"))?
            .parse()?;
        let value = parts
            .next()
            .map(|s| format!("0x{:0>64}", s.trim_start_matches("0x")))
            .ok_or_else(|| eyre!("missing value"))?
            .parse()?;
        Ok(Slot(address, value))
    }
}

#[derive(Parser)]
pub struct ExploitCmd {
    #[arg(long)]
    pub block_number: u64,
    #[arg(long)]
    pub eth_rpc_url: String,
    #[arg(long)]
    contract_path: String,
    #[arg(long)]
    transaction: Bytes,
    #[arg(long, value_delimiter = ' ')]
    pub exploited_slots: Vec<Slot>,
}

impl ExploitCmd {
    pub async fn run(self) -> eyre::Result<()> {
        // Set up the anvil provider
        let provider = LocalProvider::new(self.eth_rpc_url.clone(), self.block_number).await;
        let chain_id = provider.chain_id();

        println!("Anvil is ready...");
        println!("Waiting for the exploit to be sent... Press enter once state is set and exploit transaction has been sent.");
        let _ = tokio::io::AsyncReadExt::read(&mut tokio::io::stdin(), &mut [0u8]).await?;

        // Fetch the latest transaction
        let block = provider
            .block_by_number_full(Default::default())
            .await?
            .ok_or_else(|| eyre!("unknown block number"))?;
        let block_number = block
            .header
            .number
            .ok_or_else(|| eyre!("block number not found"))?;

        let tx = block
            .transactions
            .as_transactions()
            .expect("should be full block")
            .last()
            .cloned()
            .ok_or_else(|| eyre!("block empty, expected exploit transaction"))?;
        let tx_hash = tx.hash;

        // Construct the environments
        let (block_env, cfg_env, tx_env) = envs(block, tx, chain_id);

        // Fetch the touched state
        let touched_state = provider
            .fetch_touched_state(tx_hash, block_number - 1)
            .await?;

        // Init the prover
        let client = ProverClient::local();

        // Create a new SP1Stdin instance and write the guesses to it
        let mut input = SP1Stdin::new();

        // Prepare the slots to commit to
        let slots = self
            .exploited_slots
            .iter()
            .map(|slot| (slot.0, slot.1))
            .collect::<Vec<_>>();
        tracing::info!(?slots);

        // Write the ExecutionHost
        input.write(&block_env);
        input.write(&cfg_env);
        input.write(&tx_env);
        input.write(&touched_state.bytecodes);
        input.write(&touched_state.balances);
        input.write(&touched_state.storages);
        input.write(&touched_state.nonces);
        input.write(&slots);

        // Execute the exploit
        let (values, report) = client
            .execute(ELF, input)
            .map_err(|err| eyre!(err.to_string()))?;
        tracing::info!("exploited");
        tracing::trace!(?report);

        // Deserialize the updated state from the public values
        let final_state: Vec<U256> =
            bincode::deserialize(&values.to_vec()).map_err(|err| eyre!(err.to_string()))?;

        // Display the final state
        tracing::info!(?final_state);

        Ok(())
    }
}

/// Deploy the contract at the provided path onto the network
/// at a constant address.
async fn deploy_contract_deterministic(
    path: PathBuf,
    provider: &LocalProvider,
) -> eyre::Result<()> {
    // Compile the contract
    compile_contract(&path)?;

    // Read the compiled contract
    // solcjs compiles the contract with a name
    // which contains the  where '.' and '/' are replaced with '_'
    let stem = path
        .file_stem()
        .unwrap_or_default()
        .to_str()
        .unwrap_or_default();
    let path = path.to_str().unwrap_or_default();
    let path = path.replace(['/', '.'], "_");

    let artifact_path = format!("./artifacts/{}_{}.bin", path, stem);
    let raw = std::fs::read(artifact_path)?;

    // Convert to bytes
    let bytecode = Bytes::from(raw);

    // Deploy the contract
    provider
        .anvil_set_code(*constants::DEPLOYED_CONTRACT_ADDRESS, bytecode)
        .await?;

    Ok(())
}

/// Compile the provided contract and store it in the artifacts directory
fn compile_contract(path: &PathBuf) -> eyre::Result<()> {
    let output = std::process::Command::new("solcjs")
        .arg("--output-dir")
        .arg("./artifacts")
        .arg("--bin")
        .arg(path)
        .output()?;
    if !output.status.success() {
        return Err(eyre!("failed to compile contract"));
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::{compile_contract, constants, deploy_contract_deterministic};
    use crate::utils::provider::LocalProvider;

    const CONTRACT_PATH: &str =
        "../test/exploits/wrong_constructor_name/Rubixi_source_code/Rubixi.sol";

    #[test]
    fn test_compile_contract() {
        let path = std::path::PathBuf::from(CONTRACT_PATH);

        // Compile the contract
        let res = compile_contract(&path);
        assert!(res.is_ok());

        // Cleanup
        std::fs::remove_dir_all("./artifacts").unwrap()
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_deploy() -> eyre::Result<()> {
        let path = std::path::PathBuf::from(CONTRACT_PATH);
        let provider =
            LocalProvider::new("https://gateway.tenderly.co/public/sepolia".into(), 0).await;

        deploy_contract_deterministic(path, &provider).await?;

        let code = provider
            .get_code(*constants::DEPLOYED_CONTRACT_ADDRESS, None)
            .await?;

        assert!(!code.is_empty());

        // Cleanup
        std::fs::remove_dir_all("./artifacts").unwrap();

        Ok(())
    }
}
