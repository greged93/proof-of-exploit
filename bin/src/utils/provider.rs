use alloy::primitives::B256;
use alloy::rpc::types::trace::geth::{GethDebugTracingOptions, GethDefaultTracingOptions};
use anvil::eth::EthApi;
use anvil::NodeConfig;
use common::{Balances, Bytecodes, Nonces, StateProvingInput, Storages};
use revm_interpreter::primitives::{Address, Bytes, U256};
use std::collections::HashSet;
use std::ops::Deref;
use tracing::instrument;

/// Wrapper struct for the state of the chain which
/// has been touched by the exploit transaction.
pub struct TouchedState {
    pub addresses: Vec<Address>,
    pub bytecodes: Bytecodes,
    pub storages: Storages,
    pub balances: Balances,
    pub nonces: Nonces,
}

impl Into<StateProvingInput> for TouchedState {
    fn into(self) -> StateProvingInput {
        StateProvingInput {
            bytecodes: self.bytecodes,
            storages: self.storages,
            balances: self.balances,
            nonces: self.nonces,
        }
    }
}

#[derive(Clone)]
pub struct LocalProvider(EthApi);

impl LocalProvider {
    const BASE_FEE: u128 = 0;

    /// Creates a new local self using anvil, forking the chain
    /// with the given Ethereum RPC URL and block number.
    pub async fn new(eth_rpc_url: String, block_number: u64, port: u16) -> Self {
        let node = NodeConfig::default()
            .with_eth_rpc_url(eth_rpc_url.into())
            .with_fork_block_number(block_number.into())
            .with_base_fee(Some(Self::BASE_FEE))
            .silent()
            .with_steps_tracing(true)
            .with_port(port);
        let (eth_api, _) = anvil::spawn(node).await;

        Self(eth_api)
    }

    /// Returns a tuple containing list of addresses that were touched by the transaction
    /// and the storage slots that were touched by the transaction coupled with the address.
    pub async fn touched_addresses_and_slots(
        &self,
        tx_hash: B256,
    ) -> eyre::Result<(Vec<Address>, Vec<(Address, U256)>)> {
        // Use trace_transaction to fetch the addresses touched by the transaction
        let traces = self.trace_transaction(tx_hash).await?;
        let mut addresses: Vec<_> = traces
            .iter()
            .filter_map(|t| t.trace.action.as_call().map(|c| c.to))
            .collect();
        // Add the transaction sender
        let sender = traces
            .first()
            .and_then(|t| t.trace.action.as_call().map(|c| c.from));
        if let Some(s) = sender {
            addresses.push(s);
        }

        // Use debug_trace_transaction to fetch the storage slots touched by the transaction and combine
        // with the addresses
        let config = GethDefaultTracingOptions::default().with_disable_storage(false);
        let trace = self
            .debug_trace_transaction(
                tx_hash,
                GethDebugTracingOptions {
                    config,
                    ..Default::default()
                },
            )
            .await?;

        let copy = addresses.clone();
        let slots = trace
            .try_into_default_frame()?
            .struct_logs
            .into_iter()
            .filter(|log| log.storage.is_some())
            .flat_map(|log| {
                // Depth starts from 1.
                // Use the depth to get the address of the current contract
                tracing::info!(target: "helpers::self", depth = ?log.depth);
                let address = copy
                    .get((log.depth - 1) as usize)
                    .copied()
                    .expect("address not found");
                log.storage
                    .unwrap() // safe due to `filter_map`
                    .into_iter()
                    .map(move |s| (address, U256::from_be_slice(s.0.as_slice())))
            });

        let unique_addresses: HashSet<Address> = addresses.into_iter().collect();
        let unique_slots: HashSet<(Address, U256)> = slots.collect();

        Ok((
            unique_addresses.into_iter().collect(),
            unique_slots.into_iter().collect(),
        ))
    }

    /// Fetches the state of the chain which has been touched by the provided transaction
    /// at the given block number.
    #[instrument(skip_all)]
    pub async fn fetch_touched_state(
        &self,
        tx_hash: B256,
        block_number: u64,
    ) -> eyre::Result<TouchedState> {
        // Load bytecodes, balances and storages
        let (touched_addresses, touched_slots) = self.touched_addresses_and_slots(tx_hash).await?;

        // Fetch the bytecodes
        let bytecodes = self
            .get_codes(touched_addresses.clone(), block_number)
            .await?;

        // Fetch the balances
        let balances = self
            .get_balances(touched_addresses.clone(), block_number)
            .await?;

        // Fetch the storages
        let storages = self.get_storages(touched_slots, block_number).await?;

        // Fetch the nonces
        let nonces = self
            .get_nonces(touched_addresses.clone(), block_number)
            .await?;
        tracing::info!(?bytecodes, ?storages, ?balances, ?nonces);

        Ok(TouchedState {
            addresses: touched_addresses,
            bytecodes,
            storages,
            balances,
            nonces,
        })
    }

    /// Returns a list of tuples containing the address
    /// and its corresponding bytecode for the given
    /// block.
    pub async fn get_codes(
        &self,
        addresses: Vec<Address>,
        block_number: u64,
    ) -> eyre::Result<Vec<(Address, Bytes)>> {
        let mut bytecodes = Vec::new();
        for address in addresses {
            let code = self.get_code(address, Some(block_number.into())).await?;
            bytecodes.push((address, code));
        }
        bytecodes.retain(|(_, code)| !code.is_empty());
        Ok(bytecodes)
    }

    /// Returns a list of tuples containing the address
    /// and its corresponding balance for the given
    /// block.
    pub async fn get_balances(
        &self,
        addresses: Vec<Address>,
        block_number: u64,
    ) -> eyre::Result<Vec<(Address, U256)>> {
        let mut balances = Vec::new();
        for address in addresses {
            let code = self.balance(address, Some(block_number.into())).await?;
            balances.push((address, code));
        }
        balances.retain(|(_, balance)| balance != &U256::ZERO);
        Ok(balances)
    }

    /// Returns a list of tuples containing the address
    /// and its corresponding storage value for the given
    /// block.
    pub async fn get_storages(
        &self,
        slots: Vec<(Address, U256)>,
        block_number: u64,
    ) -> eyre::Result<Vec<((Address, U256), U256)>> {
        let mut storages = Vec::new();
        for (address, index) in slots {
            let value = self
                .storage_at(address, index, Some(block_number.into()))
                .await?;
            storages.push(((address, index), U256::from_be_slice(value.as_slice())));
        }
        storages.retain(|(_, storage)| storage != &U256::ZERO);
        Ok(storages)
    }

    /// Returns a list of tuples containing the address
    /// and its corresponding nonce value for the given
    /// block.
    pub async fn get_nonces(
        &self,
        addresses: Vec<Address>,
        block_number: u64,
    ) -> eyre::Result<Vec<(Address, u64)>> {
        let mut nonces = Vec::new();
        for address in addresses {
            let nonce = self
                .transaction_count(address, Some(block_number.into()))
                .await?;
            nonces.push((address, nonce.to()));
        }
        nonces.retain(|(_, nonce)| nonce != &0);
        Ok(nonces)
    }
}

impl Deref for LocalProvider {
    type Target = EthApi;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
