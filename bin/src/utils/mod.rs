use crate::commands::example::constants::{PRIVATE_KEY, SIGNER_ADDRESS};
use crate::utils::provider::LocalProvider;
use reth_primitives::{sign_message, TransactionSigned, TxLegacy};
use revm_interpreter::primitives::{Bytes, TxKind, B256};

pub mod env;
pub mod provider;

/// Prepares, signs and sends the exploit transaction
pub async fn prepare_and_send_transaction(
    local_provider: &LocalProvider,
    chain_id: u64,
    input: Bytes,
    to: TxKind,
) -> eyre::Result<B256> {
    // Fetch account nonce
    let nonce = local_provider
        .transaction_count(*SIGNER_ADDRESS, None)
        .await?;

    // Prepare the transaction
    let transaction = reth_primitives::Transaction::Legacy(TxLegacy {
        chain_id: Some(chain_id),
        nonce: nonce.to(),
        gas_price: 0,
        gas_limit: 2_000_000,
        to,
        value: Default::default(),
        input,
    });

    let tx_hash = sign_and_send_transaction(local_provider, transaction).await?;

    tracing::info!(?tx_hash, "transaction sent");

    // Wait for the block to be auto-mined
    tokio::time::sleep(std::time::Duration::from_millis(400)).await;

    Ok(tx_hash)
}

/// Prepares, signs and sends the transaction
pub async fn sign_and_send_transaction(
    local_provider: &LocalProvider,
    transaction: reth_primitives::Transaction,
) -> eyre::Result<B256> {
    // Sign the transaction
    let signature = sign_message(*PRIVATE_KEY, transaction.signature_hash())?;
    let signed_transaction =
        TransactionSigned::from_transaction_and_signature(transaction, signature);

    // Send the transaction
    let mut raw = Vec::new();
    signed_transaction.encode_enveloped(&mut raw);
    let tx_hash = local_provider.send_raw_transaction(raw.into()).await?;

    Ok(tx_hash)
}
