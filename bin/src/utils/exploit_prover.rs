use common::{EnvProvingInput, ProvingCommitSlot, StateProvingInput};
use eyre::eyre;
use revm_interpreter::primitives::{Address, U256};
use sp1_sdk::{ProverClient, SP1Stdin};

pub const ELF: &[u8] = include_bytes!("../../../elf/riscv32im-succinct-zkvm-elf");

/// The prover for the exploit proof
pub struct ExploitProver {
    env: EnvProvingInput,
    state: StateProvingInput,
    exploit_slots: Vec<ProvingCommitSlot>,
}

impl ExploitProver {
    /// Creates a new exploit prover
    pub fn new(
        env: EnvProvingInput,
        state: StateProvingInput,
        exploit_slots: Vec<(Address, U256)>,
    ) -> Self {
        Self {
            env,
            state,
            exploit_slots,
        }
    }

    /// Proves the exploit
    pub fn prove(&self) -> eyre::Result<()> {
        // Init the prover
        let client = ProverClient::local();

        // Create a new SP1Stdin instance and write the guesses to it
        let mut input = SP1Stdin::new();

        // Write the exploit input
        tracing::info!("proving exploit");
        tracing::info!(?self.env);

        input.write(&self.env.block_env);
        input.write(&self.env.cfg_env);
        input.write(&self.env.tx_env);
        input.write(&self.state);
        input.write(&self.exploit_slots);

        // Execute the exploit
        let (values, report) = client
            .execute(ELF, input)
            .run()
            .map_err(|err| eyre!(err.to_string()))?;
        tracing::info!("exploited");
        tracing::trace!(?report);

        // Deserialize the updated state from the public values
        let final_state: Vec<U256> =
            bincode::deserialize(&values.to_vec()).map_err(|err| eyre!(err.to_string()))?;

        // Display the final state
        tracing::info!(?final_state);

        Ok(())
    }
}
