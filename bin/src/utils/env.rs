use alloy::primitives::U256;
use alloy::rpc::types::{Block, Transaction};
use exploit_program::prover_types::TxEnv;
use eyre::eyre;
use revm_interpreter::primitives::bitvec::macros::internal::funty::Fundamental;
use revm_interpreter::primitives::{BlobExcessGasAndPrice, BlockEnv, CfgEnv};

pub fn envs(block: Block, tx: Transaction, chain_id: u64) -> (BlockEnv, CfgEnv, TxEnv) {
    let block_env = block_env(block).unwrap();
    let cfg_env = CfgEnv::default().with_chain_id(chain_id);
    let tx_env = tx_env(tx);

    (block_env, cfg_env, tx_env)
}

pub fn tx_env(tx: Transaction) -> TxEnv {
    TxEnv {
        caller: tx.from,
        data: tx.input,
        gas_limit: tx.gas.as_u64(),
        gas_price: U256::from(tx.gas_price.unwrap_or_default()),
        transact_to: tx.to.into(),
        value: tx.value,
        nonce: Some(tx.nonce),
        chain_id: tx.chain_id,
    }
}

pub fn block_env(block: Block) -> eyre::Result<BlockEnv> {
    let is_blob_block = block.header.excess_blob_gas.is_some();

    Ok(BlockEnv {
        number: U256::from(
            block
                .header
                .number
                .ok_or_else(|| eyre!("block number not found"))?,
        ),
        coinbase: block.header.miner,
        timestamp: U256::from(block.header.timestamp),
        gas_limit: U256::from(block.header.gas_limit),
        basefee: U256::from(block.header.base_fee_per_gas.unwrap_or_default()),
        difficulty: U256::from(block.header.difficulty),
        prevrandao: block.header.mix_hash,
        blob_excess_gas_and_price: if is_blob_block {
            Some(BlobExcessGasAndPrice::new(
                block.header.excess_blob_gas.unwrap_or_default().as_u64(),
            ))
        } else {
            None
        },
    })
}
