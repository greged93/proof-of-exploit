use crate::utils::provider::LocalProvider;
use alloy_signer::Signer;
use alloy_signer_local::PrivateKeySigner;
use reth_primitives::{Signature, TransactionSigned};
use revm_interpreter::primitives::{Address, Bytes, TxKind, B256};

const GAS_LIMIT: u64 = 2_000_000;
const GAS_PRICE: u128 = 0;

/// Building state of the transaction handler
pub struct Build;
/// Transmitting state of the transaction handler
pub struct Transmitting;

/// Allows to build transactions, sign them and
/// send them to the network
pub struct TransactionHandler<'a, T = Build> {
    input: Option<Bytes>,
    to: Option<Address>,
    signer: PrivateKeySigner,
    provider: &'a LocalProvider,
    state: std::marker::PhantomData<T>,
}

impl<'a> TransactionHandler<'a> {
    pub fn new(provider: &LocalProvider, signer: PrivateKeySigner) -> TransactionHandler<Build> {
        TransactionHandler {
            input: None,
            to: None,
            signer,
            provider,
            state: std::marker::PhantomData,
        }
    }
}

impl<'a> TransactionHandler<'a, Build> {
    /// Sets the input data of the transaction.
    pub fn with_input(mut self, input: Bytes) -> Self {
        self.input = Some(input);
        self
    }

    /// Sets the recipient of the transaction.
    pub fn with_to(mut self, to: Address) -> Self {
        self.to = Some(to);
        self
    }

    /// Builds the transaction handler, indicating the
    /// intention to send the transaction.
    pub fn build(self) -> TransactionHandler<'a, Transmitting> {
        TransactionHandler {
            input: self.input,
            to: self.to,
            signer: self.signer,
            provider: self.provider,
            state: std::marker::PhantomData,
        }
    }
}

impl<'a> TransactionHandler<'a, Transmitting> {
    /// Signs the transaction with the signer
    /// and sends it to the network.
    ///
    /// Returns the transaction hash
    pub async fn send(mut self) -> eyre::Result<B256> {
        let input = self.input.take();
        let to = self.to.take().map(TxKind::Call).unwrap_or(TxKind::Create);

        // Fetch account nonce
        let nonce = self
            .provider
            .transaction_count(self.signer.address(), None)
            .await?;

        // Prepare the transaction
        let transaction = reth_primitives::Transaction::Legacy(reth_primitives::TxLegacy {
            chain_id: Some(self.provider.chain_id()),
            nonce: nonce.to(),
            gas_price: GAS_PRICE,
            gas_limit: GAS_LIMIT,
            to,
            value: Default::default(),
            input: input.unwrap_or_default(),
        });

        // Sign the transaction
        let signature = self.signer.sign_hash(&transaction.signature_hash()).await?;
        let signature = Signature {
            r: signature.r(),
            s: signature.s(),
            odd_y_parity: signature.v().y_parity(),
        };
        let signed_transaction =
            TransactionSigned::from_transaction_and_signature(transaction, signature);

        // Send the transaction
        let mut raw = Vec::new();
        signed_transaction.encode_enveloped(&mut raw);
        let tx_hash = self.provider.send_raw_transaction(raw.into()).await?;

        // Wait for the block to be auto-mined
        tokio::time::sleep(std::time::Duration::from_millis(800)).await;

        Ok(tx_hash)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::random;
    use std::str::FromStr;

    #[tokio::test(flavor = "multi_thread")]
    async fn test_transaction_handler() {
        // Start the provider and the signer
        let port = random();
        let provider =
            LocalProvider::new("https://gateway.tenderly.co/public/sepolia".into(), 0, port).await;
        let signer = PrivateKeySigner::from_str(
            "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
        )
        .unwrap();

        // Create the transaction handler
        let handler = TransactionHandler::new(&provider, signer)
            .with_input(Bytes::default())
            .with_to(Address::random())
            .build();

        // Send the transaction
        let hash = handler.send().await.unwrap();

        // Verify that a receipt exists for the hash
        let _ = provider.transaction_receipt(hash).await.unwrap().unwrap();
    }
}
