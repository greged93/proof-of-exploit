use alloy::primitives::{Address, Bytes, Log, B256, U256};
use revm_interpreter::primitives::{Env, KECCAK_EMPTY};
use revm_interpreter::{Host, LoadAccountResult, SStoreResult, SelfDestructResult};
use std::collections::hash_map::Entry;
use std::collections::HashMap;

/// A host for the EVM interpreter.
/// Slightly extends the dummy host provided
/// by revm-interpreter [`revm_interpreter::DummyHost`]
/// and adds balance and block hashes
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct ExecutionHost {
    pub env: Env,
    pub storage: HashMap<(Address, U256), U256>,
    pub balance: HashMap<Address, U256>,
    pub code: HashMap<Address, Bytes>,
    pub block_hashes: HashMap<u64, B256>,
    pub transient_storage: HashMap<U256, U256>,
    pub log: Vec<Log>,
}

impl ExecutionHost {
    /// Create a new host with the given [`Env`].
    #[inline]
    pub fn new(env: Env) -> Self {
        Self {
            env,
            ..Default::default()
        }
    }
}

impl Host for ExecutionHost {
    #[inline]
    fn env(&self) -> &Env {
        &self.env
    }

    #[inline]
    fn env_mut(&mut self) -> &mut Env {
        &mut self.env
    }

    #[inline]
    fn load_account(&mut self, address: Address) -> Option<LoadAccountResult> {
        let code = self.code.contains_key(&address);
        dbg!("in load account address {:?} is_empty {:?}", address, !code);
        Some(LoadAccountResult {
            is_cold: false,
            is_empty: !code,
        })
    }

    #[inline]
    fn block_hash(&mut self, number: u64) -> Option<B256> {
        dbg!(number);
        self.block_hashes.get(&number).copied()
    }

    #[inline]
    fn balance(&mut self, address: Address) -> Option<(U256, bool)> {
        dbg!("in balance {:?}", address);
        self.balance.get(&address).map(|balance| (*balance, false))
    }

    #[inline]
    fn code(&mut self, address: Address) -> Option<(Bytes, bool)> {
        dbg!("in code {:?}", address);
        self.code.get(&address).map(|code| (code.clone(), false))
    }

    #[inline]
    fn code_hash(&mut self, _address: Address) -> Option<(B256, bool)> {
        dbg!("in code hash {:?}", _address);
        Some((KECCAK_EMPTY, false))
    }

    #[inline]
    fn sload(&mut self, address: Address, index: U256) -> Option<(U256, bool)> {
        dbg!("in sload {:?} {:?}", address, index);
        match self.storage.entry((address, index)) {
            Entry::Occupied(entry) => Some((*entry.get(), false)),
            Entry::Vacant(entry) => {
                entry.insert(U256::ZERO);
                Some((U256::ZERO, true))
            }
        }
    }

    #[inline]
    fn sstore(&mut self, address: Address, index: U256, value: U256) -> Option<SStoreResult> {
        dbg!("in sload {:?} {:?}", address, index);
        let present = self.storage.insert((address, index), value);
        Some(SStoreResult {
            original_value: U256::ZERO,
            present_value: present.unwrap_or(U256::ZERO),
            new_value: value,
            is_cold: present.is_none(),
        })
    }

    #[inline]
    fn tload(&mut self, _address: Address, index: U256) -> U256 {
        self.transient_storage
            .get(&index)
            .copied()
            .unwrap_or_default()
    }

    #[inline]
    fn tstore(&mut self, _address: Address, index: U256, value: U256) {
        self.transient_storage.insert(index, value);
    }

    #[inline]
    fn log(&mut self, log: Log) {
        self.log.push(log)
    }

    #[inline]
    fn selfdestruct(&mut self, _address: Address, _target: Address) -> Option<SelfDestructResult> {
        Some(SelfDestructResult::default())
    }
}
