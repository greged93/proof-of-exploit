use alloy::primitives::{Address, Bytes, B256, U256};
use revm_interpreter::primitives::db::Database;
use revm_interpreter::primitives::{AccountInfo, Bytecode, KECCAK_EMPTY};
use std::collections::HashMap;

/// A In Memory Database for the Evm execution.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct InMemoryDatabase {
    pub storage: HashMap<(Address, U256), U256>,
    pub balance: HashMap<Address, U256>,
    pub code: HashMap<Address, Bytes>,
    pub nonce: HashMap<Address, u64>,
    pub block_hashes: HashMap<u64, B256>,
}

impl Database for InMemoryDatabase {
    type Error = eyre::Error;

    fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
        let balance = self.balance.get(&address).copied().unwrap_or_default();
        let nonce = self.nonce.get(&address).copied().unwrap_or_default();
        let code = self.code.get(&address).cloned().map(Bytecode::LegacyRaw);
        let code_hash = code.as_ref().map(|b| b.hash_slow()).unwrap_or(KECCAK_EMPTY);

        Ok(Some(AccountInfo {
            balance,
            nonce,
            code,
            code_hash,
        }))
    }

    fn code_by_hash(&mut self, _code_hash: B256) -> Result<Bytecode, Self::Error> {
        todo!()
    }

    fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
        Ok(self
            .storage
            .get(&(address, index))
            .copied()
            .unwrap_or_default())
    }

    fn block_hash(&mut self, number: u64) -> Result<B256, Self::Error> {
        Ok(self.block_hashes.get(&number).copied().unwrap_or_default())
    }
}
