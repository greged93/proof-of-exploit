// These two lines are necessary for the program to properly compile.
//
// Under the hood, we wrap your main function with some extra code so that it behaves properly
// inside the zkVM.
#![no_main]
sp1_zkvm::entrypoint!(main);

use exploit_program::host::ExecutionHost;
use exploit_program::interpreter::{init_interpreter, run_interpreter};
use exploit_program::TxEnv;
use revm_interpreter::primitives::{Address, BlockEnv, Bytes, CfgEnv, Env, U256};
use revm_interpreter::{Host, Interpreter};

pub fn main() {
    // Read the input to the program.

    // The input should be in order:
    // - The block environment
    // - The config environment
    // - The transaction environment
    // - The bytecodes of the touched addresses
    // - The balances of the touched addresses
    // - The storages of the touched slots per address
    // - The target address and storage slot to commit
    let block_env = sp1_zkvm::io::read::<BlockEnv>();
    let cfg_env = sp1_zkvm::io::read::<CfgEnv>();
    let tx_env: revm_interpreter::primitives::TxEnv = sp1_zkvm::io::read::<TxEnv>().into();
    let env = Env {
        block: block_env,
        cfg: cfg_env,
        tx: tx_env,
    };

    let bytecodes = sp1_zkvm::io::read::<Vec<(Address, Bytes)>>();
    let balances = sp1_zkvm::io::read::<Vec<(Address, U256)>>();
    let storages = sp1_zkvm::io::read::<Vec<((Address, U256), U256)>>();

    let host = ExecutionHost {
        env,
        code: bytecodes.into_iter().collect(),
        balance: balances.into_iter().collect(),
        storage: storages.into_iter().collect(),
        ..Default::default()
    };

    // Fetch the bytecode from the host
    let to = host.env.tx.transact_to.to().unwrap();
    let bytecode = host.code.get(to).unwrap().clone();

    // Initialize the interpreter
    let mut interpreter = init_interpreter(host.env(), bytecode);

    // Run the interpreter with the given storage
    let host = run_interpreter(host, &mut interpreter).unwrap();

    let (address, index) = sp1_zkvm::io::read::<(Address, U256)>();
    let target_slot = host
        .storage
        .get(&(address, index))
        .copied()
        .unwrap_or_default();

    // Commit the result of the execution
    sp1_zkvm::io::commit(&target_slot);
}
