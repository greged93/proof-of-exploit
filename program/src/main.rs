// These two lines are necessary for the program to properly compile.
//
// Under the hood, we wrap your main function with some extra code so that it behaves properly
// inside the zkVM.
#![no_main]
sp1_zkvm::entrypoint!(main);

use exploit_program::db::InMemoryDatabase;
use exploit_program::evm::run_evm;
use exploit_program::prover_types::{ProvingCommitSlot, StateProvingInput, TxEnv};
use revm::EvmBuilder;
use revm_interpreter::primitives::{BlockEnv, CfgEnv, Env};

pub fn main() {
    // Read the input to the program.

    // The input should be in order:
    // - The block environment
    // - The config environment
    // - The transaction environment
    // - The bytecodes of the touched addresses
    // - The balances of the touched addresses
    // - The storages of the touched slots per address
    // - The nonces of the touched addresses
    // - The list of slots to commit to after execution
    let block_env = sp1_zkvm::io::read::<BlockEnv>();
    let cfg_env = sp1_zkvm::io::read::<CfgEnv>();
    let tx_env = sp1_zkvm::io::read::<TxEnv>();
    let state = sp1_zkvm::io::read::<StateProvingInput>();
    let target_slots = sp1_zkvm::io::read::<Vec<ProvingCommitSlot>>();
    let env = Env {
        block: block_env,
        cfg: cfg_env,
        tx: tx_env.into(),
    };

    // Initialize the db with the given environment
    let db = InMemoryDatabase {
        code: state.bytecodes.into_iter().collect(),
        balance: state.balances.into_iter().collect(),
        storage: state.storages.into_iter().collect(),
        nonce: state.nonces.into_iter().collect(),
        ..Default::default()
    };

    // Initialize the evm
    let evm = EvmBuilder::default()
        .with_env(env.into())
        .with_db(db)
        .build();
    let res = run_evm(evm).unwrap();

    // Iterate the slots and fetch the value from the post execution state
    let target_values: Vec<_> = target_slots
        .into_iter()
        .map(|(address, index)| {
            res.state
                .get(&address)
                .map(|acc| {
                    acc.storage
                        .get(&index)
                        .cloned()
                        .unwrap_or_default()
                        .present_value
                })
                .unwrap_or_default()
        })
        .collect();

    // Commit the result of the execution
    sp1_zkvm::io::commit(&target_values);
}
