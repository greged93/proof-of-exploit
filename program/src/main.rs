// These two lines are necessary for the program to properly compile.
//
// Under the hood, we wrap your main function with some extra code so that it behaves properly
// inside the zkVM.
#![no_main]
sp1_zkvm::entrypoint!(main);

use exploit_program::db::InMemoryDatabase;
use exploit_program::evm::run_evm;
use exploit_program::TxEnv;
use revm::EvmBuilder;
use revm_interpreter::primitives::{Address, BlockEnv, Bytes, CfgEnv, Env, U256};

pub type ProvingCommitSlot = (Address, U256);

pub fn main() {
    // Read the input to the program.

    // The input should be in order:
    // - The block environment
    // - The config environment
    // - The transaction environment
    // - The bytecodes of the touched addresses
    // - The balances of the touched addresses
    // - The storages of the touched slots per address
    // - The nonces of the touched addresses
    // - The target address and storage slot to commit
    let block_env = sp1_zkvm::io::read::<BlockEnv>();
    let cfg_env = sp1_zkvm::io::read::<CfgEnv>();
    let tx_env: revm_interpreter::primitives::TxEnv = sp1_zkvm::io::read::<TxEnv>().into();
    let env = Env {
        block: block_env,
        cfg: cfg_env,
        tx: tx_env,
    };

    let bytecodes = sp1_zkvm::io::read::<Vec<(Address, Bytes)>>();
    let balances = sp1_zkvm::io::read::<Vec<(Address, U256)>>();
    let storages = sp1_zkvm::io::read::<Vec<((Address, U256), U256)>>();
    let nonces = sp1_zkvm::io::read::<Vec<(Address, u64)>>();

    // Initialize the db with the given environment
    let db = InMemoryDatabase {
        code: bytecodes.into_iter().collect(),
        balance: balances.into_iter().collect(),
        storage: storages.into_iter().collect(),
        nonce: nonces.into_iter().collect(),
        ..Default::default()
    };

    // Initialize the evm
    let evm = EvmBuilder::default()
        .with_env(env.into())
        .with_db(db)
        .build();
    let res = run_evm(evm).unwrap();

    let (address, index) = sp1_zkvm::io::read::<ProvingCommitSlot>();
    let target_slot = res
        .state
        .get(&address)
        .map(|acc| {
            acc.storage
                .get(&index)
                .cloned()
                .unwrap_or_default()
                .present_value
        })
        .unwrap_or_default();

    // Commit the result of the execution
    sp1_zkvm::io::commit(&target_slot);
}
